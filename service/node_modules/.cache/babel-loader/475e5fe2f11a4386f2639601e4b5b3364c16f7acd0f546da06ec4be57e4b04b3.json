{"ast":null,"code":"const GameEvent = {\n  System: 'system',\n  End: 'gameEnd',\n  Start: 'gameStart'\n};\nclass EventMessage {\n  constructor(from, type, value) {\n    this.from = from;\n    this.type = type;\n    this.value = value;\n  }\n}\nclass GameEventNotifier {\n  constructor() {\n    this.events = [];\n    this.handlers = [];\n    // When dev debugging we need to talk to the service and not the React debugger\n    let port = window.location.port;\n    if (process.env.NODE_ENV !== 'production') {\n      port = 3000;\n    }\n    const protocol = window.location.protocol === 'http:' ? 'ws' : 'wss';\n    this.socket = new WebSocket(`${protocol}://${window.location.hostname}:${port}/ws`);\n    this.socket.onopen = event => {\n      this.receiveEvent(new EventMessage('Simon', GameEvent.System, {\n        msg: 'connected'\n      }));\n    };\n    this.socket.onclose = event => {\n      this.receiveEvent(new EventMessage('Simon', GameEvent.System, {\n        msg: 'disconnected'\n      }));\n    };\n    this.socket.onmessage = async msg => {\n      try {\n        const event = JSON.parse(await msg.data.text());\n        this.receiveEvent(event);\n      } catch {}\n    };\n  }\n  broadcastEvent(from, type, value) {\n    const event = new EventMessage(from, type, value);\n    this.socket.send(JSON.stringify(event));\n  }\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n  removeHandler(handler) {\n    this.handlers.filter(h => h !== handler);\n  }\n  receiveEvent(event) {\n    this.events.push(event);\n    this.events.forEach(e => {\n      this.handlers.forEach(handler => {\n        handler(e);\n      });\n    });\n  }\n}\nconst GameNotifier = new GameEventNotifier();\nexport { GameEvent, GameNotifier };","map":{"version":3,"names":["GameEvent","System","End","Start","EventMessage","constructor","from","type","value","GameEventNotifier","events","handlers","port","window","location","process","env","NODE_ENV","protocol","socket","WebSocket","hostname","onopen","event","receiveEvent","msg","onclose","onmessage","JSON","parse","data","text","broadcastEvent","send","stringify","addHandler","handler","push","removeHandler","filter","h","forEach","e","GameNotifier"],"sources":["/home/kai/Documents/Github/simon-react/src/play/gameNotifier.js"],"sourcesContent":["const GameEvent = {\n  System: 'system',\n  End: 'gameEnd',\n  Start: 'gameStart',\n};\n\nclass EventMessage {\n  constructor(from, type, value) {\n    this.from = from;\n    this.type = type;\n    this.value = value;\n  }\n}\n\nclass GameEventNotifier {\n  events = [];\n  handlers = [];\n\n  constructor() {\n    // When dev debugging we need to talk to the service and not the React debugger\n    let port = window.location.port;\n    if (process.env.NODE_ENV !== 'production') {\n      port = 3000;\n    }\n\n    const protocol = window.location.protocol === 'http:' ? 'ws' : 'wss';\n    this.socket = new WebSocket(`${protocol}://${window.location.hostname}:${port}/ws`);\n    this.socket.onopen = (event) => {\n      this.receiveEvent(new EventMessage('Simon', GameEvent.System, { msg: 'connected' }));\n    };\n    this.socket.onclose = (event) => {\n      this.receiveEvent(new EventMessage('Simon', GameEvent.System, { msg: 'disconnected' }));\n    };\n    this.socket.onmessage = async (msg) => {\n      try {\n        const event = JSON.parse(await msg.data.text());\n        this.receiveEvent(event);\n      } catch {}\n    };\n  }\n\n  broadcastEvent(from, type, value) {\n    const event = new EventMessage(from, type, value);\n    this.socket.send(JSON.stringify(event));\n  }\n\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n\n  removeHandler(handler) {\n    this.handlers.filter((h) => h !== handler);\n  }\n\n  receiveEvent(event) {\n    this.events.push(event);\n\n    this.events.forEach((e) => {\n      this.handlers.forEach((handler) => {\n        handler(e);\n      });\n    });\n  }\n}\n\nconst GameNotifier = new GameEventNotifier();\nexport { GameEvent, GameNotifier };\n"],"mappings":"AAAA,MAAMA,SAAS,GAAG;EAChBC,MAAM,EAAE,QAAQ;EAChBC,GAAG,EAAE,SAAS;EACdC,KAAK,EAAE;AACT,CAAC;AAED,MAAMC,YAAY,CAAC;EACjBC,WAAW,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAC7B,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;AACF;AAEA,MAAMC,iBAAiB,CAAC;EAItBJ,WAAW,GAAG;IAAA,KAHdK,MAAM,GAAG,EAAE;IAAA,KACXC,QAAQ,GAAG,EAAE;IAGX;IACA,IAAIC,IAAI,GAAGC,MAAM,CAACC,QAAQ,CAACF,IAAI;IAC/B,IAAIG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCL,IAAI,GAAG,IAAI;IACb;IAEA,MAAMM,QAAQ,GAAGL,MAAM,CAACC,QAAQ,CAACI,QAAQ,KAAK,OAAO,GAAG,IAAI,GAAG,KAAK;IACpE,IAAI,CAACC,MAAM,GAAG,IAAIC,SAAS,CAAE,GAAEF,QAAS,MAAKL,MAAM,CAACC,QAAQ,CAACO,QAAS,IAAGT,IAAK,KAAI,CAAC;IACnF,IAAI,CAACO,MAAM,CAACG,MAAM,GAAIC,KAAK,IAAK;MAC9B,IAAI,CAACC,YAAY,CAAC,IAAIpB,YAAY,CAAC,OAAO,EAAEJ,SAAS,CAACC,MAAM,EAAE;QAAEwB,GAAG,EAAE;MAAY,CAAC,CAAC,CAAC;IACtF,CAAC;IACD,IAAI,CAACN,MAAM,CAACO,OAAO,GAAIH,KAAK,IAAK;MAC/B,IAAI,CAACC,YAAY,CAAC,IAAIpB,YAAY,CAAC,OAAO,EAAEJ,SAAS,CAACC,MAAM,EAAE;QAAEwB,GAAG,EAAE;MAAe,CAAC,CAAC,CAAC;IACzF,CAAC;IACD,IAAI,CAACN,MAAM,CAACQ,SAAS,GAAG,MAAOF,GAAG,IAAK;MACrC,IAAI;QACF,MAAMF,KAAK,GAAGK,IAAI,CAACC,KAAK,CAAC,MAAMJ,GAAG,CAACK,IAAI,CAACC,IAAI,EAAE,CAAC;QAC/C,IAAI,CAACP,YAAY,CAACD,KAAK,CAAC;MAC1B,CAAC,CAAC,MAAM,CAAC;IACX,CAAC;EACH;EAEAS,cAAc,CAAC1B,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAChC,MAAMe,KAAK,GAAG,IAAInB,YAAY,CAACE,IAAI,EAAEC,IAAI,EAAEC,KAAK,CAAC;IACjD,IAAI,CAACW,MAAM,CAACc,IAAI,CAACL,IAAI,CAACM,SAAS,CAACX,KAAK,CAAC,CAAC;EACzC;EAEAY,UAAU,CAACC,OAAO,EAAE;IAClB,IAAI,CAACzB,QAAQ,CAAC0B,IAAI,CAACD,OAAO,CAAC;EAC7B;EAEAE,aAAa,CAACF,OAAO,EAAE;IACrB,IAAI,CAACzB,QAAQ,CAAC4B,MAAM,CAAEC,CAAC,IAAKA,CAAC,KAAKJ,OAAO,CAAC;EAC5C;EAEAZ,YAAY,CAACD,KAAK,EAAE;IAClB,IAAI,CAACb,MAAM,CAAC2B,IAAI,CAACd,KAAK,CAAC;IAEvB,IAAI,CAACb,MAAM,CAAC+B,OAAO,CAAEC,CAAC,IAAK;MACzB,IAAI,CAAC/B,QAAQ,CAAC8B,OAAO,CAAEL,OAAO,IAAK;QACjCA,OAAO,CAACM,CAAC,CAAC;MACZ,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;AACF;AAEA,MAAMC,YAAY,GAAG,IAAIlC,iBAAiB,EAAE;AAC5C,SAAST,SAAS,EAAE2C,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}